---
title: "01 - Bases de R"
output: 
  html_notebook: 
    toc: true
---

R es un entorno que permite realizar una enorme cantidad de análisis estadísticos y matemáticos. El R-base tiene las bases para cualquier análisis y las herramientas para desarrollar los otros paquetes. Además de la programación estadística y matemática, R es un entorno de programación orientado a objetos, aunque las parte estadística responde más bien al paradigma funcional. 

Por esa razón es muy frecuente que al inicio de cualquier Notebook en RStudio, o script en R-base, se carguen las librerías (paquetes de sofware) necesarias para los análisis que necesitemos realizar. Es importante destacar que para poder usar un paquete tiene que estar instalado en nuestro sistema previamente.

Para instalar un paquete podemos hacerlo con el comando install.packages(), sin embargo, como es necesario instalarlo sólo una vez, puede hacerse de la siguiente manera (este comando lo instala si no está previamente instalado en el sistema):

```{r}
if(!require("tidyverse")){
    install.packages("tidyverse")
}
```

Para usar un paquete previamente instalado lo cargamos con el comando library(). Esto se realiza sólo una vez por sesión, por esa razón se lo pone en un chunk aparte y al inicio del documento:

```{r}
library("tidyverse")
library("lubridate")
library("ggplot2")
```

Seguidamente haremos una brevísima síntesis de las herramientas básicas para trabajar en este entorno.

# Sintaxis básica

## Operadores Aritméticos

Operación           Símbolo
-----------------   --------------
Suma                +
Resta               -
Multiplicación      *
División            /
Resto o módulo      %%
División entera     %/%
Potencia            ^ ó **
Raíz                ^(1/) 
Raíz cuadrada       sqrt()
-----------------   --------------
Asignación          <- ó -> ó = (no recomendado =)

## Operadores lógicos

Operación           Símbolo
-----------------   --------------
Verdadero           TRUE
Falso               FALSE
y                   &
o                   |
no                  !
Mayor               >
Mayor igual         >=
Menor               <
Menor igual         <=
Igual               ==
Distinto            !=
-----------------   --------------

## Literales especiales

Operación           Símbolo
-----------------   --------------
Dato faltante       NA
Objeto nulo         NULL
Infinito            Inf
Not a Number        NaN
-----------------   --------------

## Estructuras de control

Estructura                      Palabra
-------------------------       --------------
Condicional si TRUE             if
Condicional si FALSE            else
Repetir una serie de comandos   repeat
Mientras                        while
Repetir en un vector            for
Definir una función             function
Verificar si un elemento 
  está en una colección         in
Saltar una iteración en 
  un bucle                      next
Interrumpir un bucle            break
-------------------------       --------------

## Pipes

Operación               Símbolo
-----------------       --------------
Pipe a la derecha       %>%
-----------------       --------------

# Tipos de datos (Numeric, character , logical, y varios tipos para fechas y tiempos)

## Numeric


```{r}
a <- 1
a
class(a) # "numeric"

b <- 3.2
b
class(b) # "numeric"

c <- 1/7
c
class(c) # "numeric"

d <- (-b + sqrt(b^2 - 4*a*c) ) / ( 2*a )
d
class(d) # "numeric"

e <- (-b - sqrt(b^2 - 4*a*c) ) / ( 2*a )
e
class(e) # "numeric"
```

## Character

```{r}

f <- "b"
f
class(f) # "character"

g <- "palabra"
g
class(g) # "character"

paste(f , g)
class(paste(f , g))
paste(f, g, sep = "-")
paste(b, g, sep = "-")

```

## Logical

```{r}
a
b
c
d

b > c # TRUE
class(b > c) # "logical"

b > c
b > c & a < d 
b > c | a < d 
! b > c | a < d
```

## Date and Time.

```{r}
instante <- now()
instante # "2023-03-19 14:55:24 -03"

otroInstante <- now()
otroInstante # "2023-03-19 14:55:24 -03"
diferencia <- otroInstante - instante
diferencia

class(instante) # "POSIXct" "POSIXt"
class(diferencia)

hoy <- today()
hoy
class(hoy)

day(hoy)
month(hoy)
year(hoy)
week(hoy)

```

# Estructuras de datos

Dimensiones	    Homogeneous	    Heterogeneous
------------    ------------    --------------
1d	            Vector          List
2d	            Matrix	        Data frame / tibble
nd	            Array

## Vectores

Los vectores son conjuntos ordenados de objetos de la misma clase (o type). Se instancian con c(). Pueden contenercualquier tipo de objetos mientras sean del mismo tipo y los fuerza al mismo tipo por defecto. Las operaciones básicas funcionan elemento a elemento.

```{r}
x <- c(1, 7, 3)
y <- c(9, 4, 5.2)
x
y

x + y   # 10 11  8
x - y   # -8  3 -2
x * y   #  9 28 15
x / 2   #  0.5 3.5 1.5
x %% y  # 1 3 3
x %/% y # 0 1 0
# potencia
x ** y  # 1 2401  243 
x ^ y   # 1 2401  243

z <- c(1, 2.5, 3/7, "f")
z
```

### Generador de secuencias

```{r}
# Generan un vector con los elementos de la secuencia
vec1 <- c(1:10) # Desde : hasta
vec2 <- seq(15,50,3) # Desde, hasta, cada
vec1
vec2
```

### Acceder a los elementos de un vector

```{r}
# Vector
x[1] # 1
y[3] # 5

# Se puede accedeer a un rango de datos
vec2[3:7]
```

## Matrices

```{r}
s <- matrix(1:6, nrow = 2, ncol = 3)
t <- matrix(8:13, nrow = 2, ncol = 3)

s
t
```

```{r}
matr <- cbind(x,y)
matr
```

```{r}
matr2 <- rbind(x,y)
matr2
```

```{r}
# Suma de matrices elemento a elemento
s + t
```

```{r}
# Multiplicación de matrices elemento a elemento
paste("s * t Es el producto términoa término, ambas matrices deben tener las mismas dimensiones")
writeLines("\n")
s * t
```

```{r}
# Ten en cuenta que se necesitan las dimensiones correctas para la multiplicación de matrices
w <- matrix(8:13, nrow = 2, ncol = 3)
writeLines("\n")
paste("w")
w

z <- matrix(1:6, nrow = 3, ncol = 2)
writeLines("\n")
paste("z")
z

writeLines("\n")
paste("w %*% z Es el producto matricial, ej del primer valor 8*1 + 10*2 + 12*3 = 64")
writeLines("\n")
w %*% z

# Producto exterior
#writeLines("\n")
#paste("w %o% z")
#w %o% z # (Salida omitida)

# Producto Kronecker
writeLines("\n")
paste("w %x% z Producto Kronecker")
writeLines("\n")
w %x% z
```

### Acceder a sus elementos

```{r}
# Matriz

# Un elemento de celda, contando los elementos desde el inicio
s[1] # 1
t[3] # 10

# Un elemento de celda, con referencia de fila y columna. Coordenadas. [fila,columna]
s[1,2] # 3
t[2,3] # 13


# Una fila
s[1,] # 1 3 5
t[2,] # 9 11 13

# Una columna
s[,1] # 1 2
t[,3] # 12 13
```
## Array.

En este caso lo veremos en 3D, pero puede usarse en cualquier dimensión

```{r}
# Crear vectores, pueden tener diferente longitud. También se puede hacer desde un solo vector.
vector1 <- c(5,9,3)
vector2 <- c(10,11,12,13,14,15)
vector3 <- c(16,17,18,19,20,21,22,23,24,25,26,27,28,29,30)

# Usar los vectores creados para armar la matriz.
unArray3D <- array(c(vector1,vector2,vector3), dim = c(3,3,2))
paste(unArray3D)
```

### Acceder a sus elementos

```{r}
unArray3D[3,1,2]

writeLines("")
unArray3D[,,1]

writeLines("")
unArray3D[,2,]
```

## Estructuras de datos heterogéneos

## Listas

Pueden almacenar cualquier objeto.

```{r}
h <- list(12, s, t, w, z, now(), y, TRUE)
h
class(h)
```

En una lista los objetos pueden nombrarse

```{r}
unaLista <- list(nombre = "Rafael", apellido = "Mac Donough", fechaDeNacimiento = ymd("1970-08-23"), dni = 21486775, esHombre = TRUE)
unaLista$fechaDeNacimiento
unaLista[2]
```

### Acceder a sus elementos

```{r}
# Observar que hay dos pares de [[ ]]

h[[3]]
h[[6]]
h[[7]]
h[[8]]
```

## Data Frames

Puede tener diferentes tipos de datos en diferentes columnas (variables), pero dentro de la columna los tipos de datos deben ser homogéneos.

```{r}
unDataFrame1 <- data.frame(
  "entero" = 1:4, 
  "factor" = as.factor(c("a", "b", "c", "d")), 
  "numero" = c(1.2, 3.4, 4.5, 5.6),
  "cadena" = c("en", "fe", "go", "hu")
)
str(unDataFrame1)
unDataFrame1
```
### Acceder a sus elementos

```{r}
unDataFrame1[[1]]
unDataFrame1$factor
unDataFrame1[[4,3]]
unDataFrame1[[3]][4]
unDataFrame1[[1]][2]
unDataFrame1$cadena[3]
```

# Funciones

## Funciones básicas

Trabajemos con los datos vuestros, las medidas de las hojas. 

Largo, ancho, cantidad de folíolos, largo del pecíolo (distancia.)

```{r}
largos <- c(288,358,343,365,379,395,381)
anchos <- c(179,216,216,219,221,232,230)
foliolos <- c(12,15,18,16,17,17,19)
peciolos <- c(89,74,108,105,104,120,95)
```

```{r}
class(largos)
```

```{r}
sum(largos)
length(largos)
mean(largos)
max(largos)
min(largos)
#median(largos)
#sd(largos)
#var(largos)
```

### ¿Cómo funcionan las funcionesanteriores?

```{r}
suma <- 0 
for (i in largos) {
  suma <- suma + i
}
suma

suma2 <- 0 
for (i in 1:length(largos)) {
  suma2 <- suma2 + largos[i]
}
suma2

n <- 0 
for (i in largos) {
  n <- n + 1
}
n

media <- suma / n
media

maxi <- largos[1] 
for (i in largos) {
  if (maxi < i) {
    maxi <- i
  }
}
maxi

mini <- largos[1]
for (i in largos) {
  if (mini > i){
    mini <- i
  }
}
mini
```

### Cómo se ordena?

```{r}
sort(largos)

largosOrd <- largos
for (i in 2:length(largosOrd)) {
  v <- largosOrd[i]
  j <- i
  while ((j > 1) & (largosOrd[j-1] > v)) {
    largosOrd[j] <- largosOrd[j-1]
    largosOrd[j-1] <- v
    j <- j-1
  }
}
largosOrd
# largos
```

### Un ejemplo: la mediana

```{r}
if (length(largosOrd) %% 2 == 0) {
  (largosOrd[length(largosOrd) / 2] + largosOrd[(length(largosOrd) / 2) + 1]) / 2
} else {
  largosOrd[(length(largosOrd) / 2) + 1]
  }
```

## Escribir nuevas funciones

Para un ejemplo lo hacemos implementando el método anterior, el cálculo de la mediana.

```{r}
calcularMediana <- function(data) {
  dataOrdenado <- sort(data)
  if (length(dataOrdenado) %% 2 == 0) {
    (largosOrd[length(dataOrdenado) / 2] + dataOrdenado[(length(dataOrdenado) / 2) + 1]) / 2
    } else {
      dataOrdenado[(length(dataOrdenado) / 2) + 1]
      }
}
```

También podemos mirar la función que acabamos de crear presionando sobre el nombre de la función en el panel donde están los objetos creados en nuestro Workspace (pestaña "Environment").

Probamos la nueva función y la comparamos con los resultados calculados por median(), que es la función de R-base que hace lo mismo.

```{r}
calcularMediana(largos)
median(largos)
calcularMediana(anchos)
median(anchos)
calcularMediana(foliolos)
median(foliolos)
calcularMediana(peciolos)
median(peciolos)
```

## Conocer las funciones

Para ver cómo está programada una función que exista en nuesto sistema primero tenemos que hallar dónde está:

```{r}
methods("median")
```

Sabiendo dónde está, entonces podemos pedirle que la muestre. En este caso se puede ver que hay otros dos paquetes que implementan la misma función, por lo tanto debemos elegir cuál es la que nos interesa. Elijamos la de R-base:

```{r}
getAnywhere('median.default')
```

Vemos que el método real es más complejo, eso se debe a que está pensado para trabajar con muchos tipos de colecciones y datos posibles. Además el método tiene varias opciones que podemos conocer con:

```{r}
help("median")
```

# Pipes

Es cada vez más común en R trabajar con pipes. La idea general de esta forma de trabajar es imaginar que hacemos un procedimiento que viaja por un caño, De este modo, en un lugar determinado del caño recibimos un objeto que es el resultadode los procesos anteriores, realizamos una tarea y el resultado sigue circulando por el caño.

Esto tiene muchas ventajas:
-   El código es más corto
-   El código es más legible
-   Se crean muchos menos objetos residuales en el entorno de trabajo
-   Uso más eficiente de la memoria RAM

Mostremos un ejemplo:

```{r}
unVector <- 5:10
unVector
otroVector <- factorial(unVector)
otroVector
mediaOtroVector <- mean(otroVector)
mediaOtroVector
unaFecha <- as.Date(mediaOtroVector)
unaFecha
```

Eso mismo puede realizarse así:

```{r}
5:10 %>% factorial() %>% mean() %>% as.Date()
```

# Grafiquemos

## Primero armamos un data frame donde estén todas las variables medidas.

```{r}
dfHojas <- data.frame(largos, anchos, foliolos, peciolos)
dfHojas
```

## Box Plot

```{r}
boxplot(dfHojas, ylim=c(0,400), ylab = "Largo (cm)", xlab= "variable")
#boxplot(largos, ylim=c(0,460), ylab = "Largo (cm)", xlab= "muestra")
```

```{r}
library(ggpubr)
p1 <- ggplot(dfHojas, aes(x = "", y = largos)) + 
  geom_boxplot() +
  stat_boxplot(geom = "errorbar",
               width = 0.25) +
  geom_jitter(width = 0.1) +
  ylim(0,NA)
p2 <- ggplot(dfHojas, aes(x = "", y = anchos)) + 
  geom_boxplot() +
  stat_boxplot(geom = "errorbar",
               width = 0.25) +
  geom_jitter(width = 0.1) +
  ylim(0,NA)
p3 <- ggplot(dfHojas, aes(x = "", y = foliolos)) + 
  geom_boxplot() +
  stat_boxplot(geom = "errorbar",
               width = 0.25) +
  geom_jitter(width = 0.1) +
  ylim(0,NA)
p4 <- ggplot(dfHojas, aes(x = "", y = peciolos)) + 
  geom_boxplot() +
  stat_boxplot(geom = "errorbar",
               width = 0.25) +
  geom_jitter(width = 0.1) +
  ylim(0,NA)

ggarrange(p1, p2, p3, p4, nrow=1)
```