---
title: "25 - Regresi칩n Lineal Simple y m칰ltiple"
output: html_notebook
---

Aqu칤 les dejo una referencia muy completa y clara sorbe este tema.

Joaqu칤n Amat Rodrigo (2016). "Correlaci칩n lineal y Regresi칩n lineal simple"
<https://cienciadedatos.net/documentos/24_correlacion_y_regresion_lineal>

La primera parte es correlaci칩n (como ya se vi칩 en 21 - Covarianza y Correlaci칩n.Rmd), acceda directamente a Regresi칩n simple con este v칤nculo.
<https://cienciadedatos.net/documentos/24_correlacion_y_regresion_lineal#Regresi%C3%B3n_lineal_simple>


## Regresi칩n simple.

La regresi칩n simple tiene una sola variable cont칤nua explicatoria, pero puede tener m치s factores categ칩ricos (ver m치s adelante).

$$
Y_{i} = \beta_0 + (\beta_1 *x_i)  + \epsilon_{i}
$$
Donde:

-   Y es la variable dependiente (respuesta).
-   洧량0 es la ordenada al origen de la recta.
-   洧량1 es la pendiente de la recta.
-   xi es la variable independiente del i칠simo individuo.
-   洧릓i es el residual del individuo i칠simo respecto del valor predicho por el modelo. 
Se asume que los residuales tienen distribuci칩n normal con media 0 y varianza sigma cuadrado:

$$
\epsilon_{ij} \sim N(0, \sigma^2)
$$
```{r}
library(tidyverse)
library(ggpmisc)
```


```{r}
mtcars
help(mtcars)
```

## Regresi칩n simple

```{r}
regSimple <- lm(mpg ~ hp, data = mtcars)
summary(regSimple)
```

```{r}
# library(ggpmisc)
ggplot(mtcars, aes(x = hp, y = mpg)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, color = "firebrick") +
  stat_poly_eq(use_label(c("eq", "adj.R2", "R2", "R2.CI", "P", "n")))
```

## Regresi칩n simple con un factor

### Filtrando por una categor칤a

Se puede filtrar los datos por una categor칤a y realizar una regresi칩n simple como la anterior sobre los datos de esa categor칤a. Este procedimiento puede repetirse para cada una de las categor칤a de inter칠s y obtener varias regresiones simples separadas.

```{r}
filtrado <- mtcars %>% filter(vs == 1)
```

```{r}
regSimple2 <- lm(mpg ~ hp, data = filtrado)
summary(regSimple2)
```
```{r}
# library(ggpmisc)
ggplot(filtrado, aes(x = hp, y = mpg, fill = factor(vs))) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, color = "firebrick") +
  stat_poly_eq(use_label(c("eq", "R2"))) 
```

## Regresi칩n m칰ltiple

El m칠todo anterior sirve, pero podemos extraer m치s informaci칩n y realizar elan치lisis anterior para todas las categor칤as en un solo paso. Lo que hacemos agregar un efecto de grupo (categ칩rico) para cada nivel de un factor de inter칠s. Esto hace varias regresiones juntas (una para cada nivel del factor de clasificaci칩n) y adem치s puede probar las hip칩tesis similares a un ANOVA.

El modelo ser칤a el siguiente:

$$
Y_{ijk} = \beta_0 + \beta_1 X_i + \beta_j X_j + \beta_{1j} X_i X_j+ \epsilon_{ijk}
$$

```{r}
regConFactor <- lm(mpg ~ hp * factor(vs), data = mtcars)
summary(regConFactor)
```

```{r}
# library(ggpmisc)
ggplot(mtcars, aes(x = hp, y = mpg, fill = factor(vs))) +
  geom_point(aes(fill = factor(vs))) +
  geom_smooth(method = "lm", se = TRUE, color = "firebrick") +
  stat_poly_eq(use_label(c("eq", "R2"))) 
```

### Probando con otro factor diferente

```{r}
regConFactor2 <- lm(mpg ~ hp * factor(cyl), data = mtcars)
summary(regConFactor2)
```


```{r}
# library(ggpmisc)
ggplot(mtcars, aes(x = hp, y = mpg, fill = factor(cyl))) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, color = "firebrick") +
  stat_poly_eq(use_label(c("eq", "R2"))) 
```

### Probando con dos factores

```{r}
regConFactor2 <- lm(mpg ~ hp * factor(vs) * factor(cyl), data = mtcars)
summary(regConFactor2)
```

> Se puede ver que los p-values son demasiado altos, eso es porque en cada grupo hay pocos veh칤culos (n demasiado bajo).

No encuentro forma de graficarlo con ggplot2.
La 칰nica soluci칩n que s칠 que funcionar칤a es crear en el dataset una veriable nueva con la combinaci칩n de vs y cyl, para usarla en fill = dentro del aes() del ggplot().

```{r}

```

## Regresi칩n m칰ltiple con dos variables cont칤nuas explicadas (dependientes).

Esto es m치s dif칤cil de explicar, pero simplificando esto significa que podemos tratar de explicar una relaci칩n ente variables en vez de una variable sola.

```{r}
regMultiple <- glm(mpg * wt ~ hp * factor(cyl), data = mtcars)
summary(regMultiple)
```

